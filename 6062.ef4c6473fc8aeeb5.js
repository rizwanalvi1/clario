"use strict";(self.webpackChunkclario_frontend=self.webpackChunkclario_frontend||[]).push([[6062],{97493:(vt,yt,$)=>{$.d(yt,{Z:()=>Mt});var ft,X=$(50484),gt=$(57964),at=$(89317),ht=$(34222),dt=$(4703),Q=$(80543),xt=$(73018),q=$(10141),ut=$(12852),ot=$(86741);let it=ft=class extends at.wq{static createEmptyBand(E,B){return new(ft.getPixelArrayConstructor(E))(B)}static combineBandMasks(E){if(E.length<2)return E[0];const B=E[0].length,N=new Uint8Array(B).fill(255);for(let z=0;z<E.length;z++){const Z=E[z];for(let j=0;j<B;j++)Z[j]||(N[j]=0)}return N}static getPixelArrayConstructor(E){let B;switch(E){case"u1":case"u2":case"u4":case"u8":B=Uint8Array;break;case"u16":B=Uint16Array;break;case"u32":B=Uint32Array;break;case"s8":B=Int8Array;break;case"s16":B=Int16Array;break;case"s32":B=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":B=Float32Array;break;case"f64":B=Float64Array}return B}constructor(E){super(E),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(E){if(!E)return"f32";let B=E.toLowerCase();return["u1","u2","u4"].includes(B)?B="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(B)||(B="f32"),B}getPlaneCount(){return this.pixels?.length}addData(E){if(!E.pixels||E.pixels.length!==this.width*this.height)throw new gt.Z("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(E.pixels),this.statistics.push(E.statistics??new ut.c)}getAsRGBA(){const E=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(E);break;default:this._fillFrom8Bit(E)}return new Uint8ClampedArray(E)}getAsRGBAFloat(){const E=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(E),E}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map(N=>function mt(E,B){let N=1/0,z=-1/0;const Z=E.length;let j,O=0;if(null!=B)for(j=0;j<Z;j++)B[j]&&(O=E[j],N=O<N?O:N,z=O>z?O:z);else for(j=0;j<Z;j++)O=E[j],N=O<N?O:N,z=O>z?O:z;return new ut.c(N,z)}(N,this.mask));const E=this.mask;let B=0;if(null!=E)for(let N=0;N<E.length;N++)E[N]&&B++;else B=this.width*this.height;this.validPixelCount=B}clamp(E){if(!E||"f64"===E||"f32"===E||!this.pixels)return;const[B,N]=(0,ot.rL)(E),z=this.pixels,Z=this.width*this.height,j=z.length;let O,tt,R;const et=[];for(let H=0;H<j;H++){R=ft.createEmptyBand(E,Z),O=z[H];for(let U=0;U<Z;U++)tt=O[U],R[U]=tt>N?N:tt<B?B:tt;et.push(R)}this.pixels=et,this.pixelType=E}extractBands(E){const{pixels:B,statistics:N}=this;if(null==E||0===E.length||!B||0===B.length)return this;const z=B.length,Z=E.some(U=>U>=B.length),j=z===E.length&&!E.some((U,v)=>U!==v);if(Z||j)return this;const O=this.bandMasks?.length===z?E.map(U=>this.bandMasks[U]):void 0;let{mask:tt,validPixelCount:R}=this;const{width:et,height:H}=this;return O?.length&&(tt=ft.combineBandMasks(O),R=tt.filter(U=>!!U).length),new ft({pixelType:this.pixelType,width:et,height:H,mask:tt,bandMasks:O,validPixelCount:R,maskIsAlpha:this.maskIsAlpha,pixels:E.map(U=>B[U]),statistics:N&&E.map(U=>N[U])})}clone(){const E=new ft({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});let B;null!=this.mask&&(E.mask=new Uint8Array(this.mask)),this.bandMasks&&(E.bandMasks=this.bandMasks.map(z=>new Uint8Array(z)));const N=ft.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){E.pixels=[];const z=!!this.pixels[0].slice;for(B=0;B<this.pixels.length;B++)E.pixels[B]=z?this.pixels[B].slice(0,this.pixels[B].length):new N(this.pixels[B])}if(this.statistics)for(E.statistics=[],B=0;B<this.statistics.length;B++)E.statistics[B]=(0,ht.d9)(this.statistics[B]);return E.premultiplyAlpha=this.premultiplyAlpha,E}_fillFrom8Bit(E){const{mask:B,maskIsAlpha:N,premultiplyAlpha:z,pixels:Z}=this;if(!E||!Z?.length)return void dt.Z.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let j,O,tt,R;j=O=tt=Z[0],Z.length>=3?(O=Z[1],tt=Z[2]):2===Z.length&&(O=Z[1]);const et=new Uint32Array(E),H=this.width*this.height;if(j.length===H)if(null!=B&&B.length===H)if(N)for(R=0;R<H;R++){const U=B[R];if(U){const v=U/255;et[R]=z?U<<24|tt[R]*v<<16|O[R]*v<<8|j[R]*v:U<<24|tt[R]<<16|O[R]<<8|j[R]}}else for(R=0;R<H;R++)B[R]&&(et[R]=255<<24|tt[R]<<16|O[R]<<8|j[R]);else for(R=0;R<H;R++)et[R]=255<<24|tt[R]<<16|O[R]<<8|j[R];else dt.Z.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(E){const{pixels:B,mask:N,statistics:z}=this;if(!E||!B?.length)return void dt.Z.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const Z=this.pixelType;let j=1,O=0,tt=1;if(z&&z.length>0){for(const C of z)null!=C.minValue&&(O=Math.min(O,C.minValue)),null!=C.maxValue&&null!=C.minValue&&(tt=Math.max(tt,C.maxValue-C.minValue));j=255/tt}else{let C=255;"s8"===Z?(O=-128,C=127):"u16"===Z?C=65535:"s16"===Z?(O=-32768,C=32767):"u32"===Z?C=4294967295:"s32"===Z?(O=-2147483648,C=2147483647):"f32"===Z?(O=-34e38,C=34e38):"f64"===Z&&(O=-Number.MAX_VALUE,C=Number.MAX_VALUE),j=255/(C-O)}const R=new Uint32Array(E),et=this.width*this.height;let H,U,v,b,V;if(H=U=v=B[0],H.length!==et)return dt.Z.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(B.length>=2)if(U=B[1],B.length>=3&&(v=B[2]),null!=N&&N.length===et)for(b=0;b<et;b++)N[b]&&(R[b]=255<<24|(v[b]-O)*j<<16|(U[b]-O)*j<<8|(H[b]-O)*j);else for(b=0;b<et;b++)R[b]=255<<24|(v[b]-O)*j<<16|(U[b]-O)*j<<8|(H[b]-O)*j;else if(null!=N&&N.length===et)for(b=0;b<et;b++)V=(H[b]-O)*j,N[b]&&(R[b]=255<<24|V<<16|V<<8|V);else for(b=0;b<et;b++)V=(H[b]-O)*j,R[b]=255<<24|V<<16|V<<8|V}_fillFrom32Bit(E){const{pixels:B,mask:N}=this;if(!E||!B?.length)return dt.Z.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let z,Z,j,O;z=Z=j=B[0],B.length>=3?(Z=B[1],j=B[2]):2===B.length&&(Z=B[1]);const tt=this.width*this.height;if(z.length!==tt)return dt.Z.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let R=0;if(null!=N&&N.length===tt)for(O=0;O<tt;O++)E[R++]=z[O],E[R++]=Z[O],E[R++]=j[O],E[R++]=1&N[O];else for(O=0;O<tt;O++)E[R++]=z[O],E[R++]=Z[O],E[R++]=j[O],E[R++]=1}};(0,X._)([(0,Q.Cb)({json:{write:!0}})],it.prototype,"width",void 0),(0,X._)([(0,Q.Cb)({json:{write:!0}})],it.prototype,"height",void 0),(0,X._)([(0,Q.Cb)({json:{write:!0}})],it.prototype,"pixelType",void 0),(0,X._)([(0,xt.p)("pixelType")],it.prototype,"castPixelType",null),(0,X._)([(0,Q.Cb)({json:{write:!0}})],it.prototype,"validPixelCount",void 0),(0,X._)([(0,Q.Cb)({json:{write:!0}})],it.prototype,"mask",void 0),(0,X._)([(0,Q.Cb)({json:{write:!0}})],it.prototype,"maskIsAlpha",void 0),(0,X._)([(0,Q.Cb)({json:{write:!0}})],it.prototype,"pixels",void 0),(0,X._)([(0,Q.Cb)()],it.prototype,"premultiplyAlpha",void 0),(0,X._)([(0,Q.Cb)({json:{write:!0}})],it.prototype,"statistics",void 0),(0,X._)([(0,Q.Cb)({json:{write:!0}})],it.prototype,"depthCount",void 0),(0,X._)([(0,Q.Cb)({json:{write:!0}})],it.prototype,"noDataValues",void 0),(0,X._)([(0,Q.Cb)({json:{write:!0}})],it.prototype,"bandMasks",void 0),it=ft=(0,X._)([(0,q.j)("esri.layers.support.PixelBlock")],it);const Mt=it},12852:(vt,yt,$)=>{$.d(yt,{c:()=>X});class X{constructor(at=null,ht=null,dt=null){this.minValue=at,this.maxValue=ht,this.noDataValue=dt}}},86741:(vt,yt,$)=>{$.d(yt,{Ao:()=>xt,DV:()=>Q,JQ:()=>dt,rL:()=>ht});const X=9999999e31,gt=2e-7,at={u1:[0,1],u2:[0,3],u4:[0,15],u8:[0,255],s8:[-128,127],u16:[0,65535],s16:[-32768,32767],u32:[0,4294967295],s32:[-2147483648,2147483647],f32:[-34028234663852886e22,34028234663852886e22],f64:[-Number.MAX_VALUE,Number.MAX_VALUE],unknown:void 0,c64:void 0,c128:void 0};function ht(q){return at[q]??[-34028234663852886e22,34028234663852886e22]}function dt(q,ut){return null==q||null==ut?"s32":q<0?q>=-128&&ut<128?"s8":q>=-32768&&ut<32768?"s16":"s32":ut<256?"u8":ut<65536?"u16":"u32"}function Q(q){return(q?.startsWith("s")||q?.startsWith("u"))??!1}function xt(q,ut,ot){if(q.depthCount&&q.depthCount>1)return;const{pixels:ft,statistics:it,pixelType:mt}=q,E=q.bandMasks??[],B=q.mask??new Uint8Array(ft[0].length).fill(255),N="f32"===mt||"f64"===mt,z=ht(mt);let Z=!1;for(let j=0;j<ft.length;j++){const O="number"==typeof ut?ut:ut[j];if(null==O)continue;if((it?.[j]?.minValue??z[0])>O+Number.EPSILON||(it?.[j]?.maxValue??z[1])<O-Number.EPSILON)continue;const et=E[j]||B.slice(),H=ft[j],U=ot?.customFloatTolerance;if(N&&0!==U){let v=U;v||(v=Math.abs(O)>=X?gt*Math.abs(O):"f32"===mt?2**-23:Number.EPSILON);for(let b=0;b<H.length;b++)et[b]&&Math.abs(H[b]-O)<v&&(H[b]=0,et[b]=0,B[b]=0,Z=!0)}else for(let v=0;v<H.length;v++)et[v]&&H[v]===O&&(H[v]=0,et[v]=0,B[v]=0,Z=!0);E[j]=et}Z&&(q.bandMasks=q.bandMasks||q.pixels.length>1?E:null,q.mask=B),Z&&"updateStatistics"in q&&q.updateStatistics()}},98797:(vt,yt,$)=>{$.d(yt,{$f:()=>dt,CD:()=>ht,DX:()=>at,Gd:()=>q,Kh:()=>tt,Pz:()=>ut,Qh:()=>_,SJ:()=>ot,Uk:()=>I,Uu:()=>k,Vl:()=>w,XV:()=>ft,a2:()=>Mt,nA:()=>j,nk:()=>Q,oB:()=>Z,pW:()=>U,sS:()=>z,us:()=>et,wV:()=>it,zp:()=>mt});var at,ht,e,X=$(97493),gt=$(86741);(e=at||(at={}))[e.matchAny=0]="matchAny",e[e.matchAll=1]="matchAll",function(e){e[e.bestMatch=0]="bestMatch",e[e.fail=1]="fail"}(ht||(ht={}));const dt=6;function Q(e){return null!=e&&"esri.layers.support.PixelBlock"===e.declaredClass&&e.pixels&&e.pixels.length>0}function q(e){if(!e?.length||e.some(n=>!Q(n)))return null;if(1===e.length)return e[0]?.clone()??null;const i=e,{width:t,height:s,pixelType:l}=i[0];if(i.some(n=>n.width!==t||n.height!==s))return null;const o=i.map(({mask:n})=>n).filter(n=>null!=n);let r=null;o.length&&(r=new Uint8Array(t*s),r.set(o[0]),o.length>1&&N(o.slice(1),r));const h=[];i.forEach(({pixels:n})=>h.push(...n));const c=i.map(({statistics:n})=>n).filter(n=>n?.length),a=[];return c.forEach(n=>a.push(...n)),new X.Z({pixelType:l,width:t,height:s,mask:r,pixels:h,statistics:a.length?a:null})}function ut(e){if(!e)return;const i=e.colormap;if(!i||0===i.length)return;const t=i.sort((p,u)=>p[0]-u[0]);let s=0;t[0][0]<0&&(s=t[0][0]);const l=Math.max(256,t[t.length-1][0]-s+1),o=new Uint8Array(4*l),r=[];let h,c=0,a=0;const n=5===t[0].length;if(l>65536)return t.forEach(p=>{r[p[0]-s]=n?p.slice(1):p.slice(1).concat([255])}),{indexed2DColormap:r,offset:s,alphaSpecified:n};if(e.fillUnspecified)for(h=t[a],c=h[0]-s;c<l;c++)o[4*c]=h[1],o[4*c+1]=h[2],o[4*c+2]=h[3],o[4*c+3]=n?h[4]:255,c===h[0]-s&&(h=a===t.length-1?h:t[++a]);else for(c=0;c<t.length;c++)h=t[c],a=4*(h[0]-s),o[a]=h[1],o[a+1]=h[2],o[a+2]=h[3],o[a+3]=n?h[4]:255;return{indexedColormap:o,offset:s,alphaSpecified:n}}function ot(e,i){if(!Q(e)||!i||!i.indexedColormap&&!i.indexed2DColormap)return e;const t=e.clone(),s=t.pixels;let l=t.mask;const o=t.width*t.height;if(1!==s.length)return e;const{indexedColormap:r,indexed2DColormap:h,offset:c,alphaSpecified:a}=i;let n=0;const p=s[0],u=new Uint8Array(p.length),f=new Uint8Array(p.length),m=new Uint8Array(p.length);let x,g=0;if(r){const A=r.length-1;if(null!=l)for(n=0;n<o;n++)l[n]&&(g=4*(p[n]-c),g<c||g>A?l[n]=0:(u[n]=r[g],f[n]=r[g+1],m[n]=r[g+2],l[n]=r[g+3]));else{for(l=new Uint8Array(o),n=0;n<o;n++)g=4*(p[n]-c),g<c||g>A?l[n]=0:(u[n]=r[g],f[n]=r[g+1],m[n]=r[g+2],l[n]=r[g+3]);t.mask=l}}else if(h)if(null!=l)for(n=0;n<o;n++)l[n]&&(x=h[p[n]],u[n]=x[0],f[n]=x[1],m[n]=x[2],l[n]=x[3]);else{for(l=new Uint8Array(o),n=0;n<o;n++)x=h[p[n]],u[n]=x[0],f[n]=x[1],m[n]=x[2],l[n]=x[3];t.mask=l}return t.pixels=[u,f,m],t.statistics=null,t.pixelType="u8",t.maskIsAlpha=a,t}function ft(e,i){if(!Q(e))return null;const{pixels:t,mask:s}=e,l=t.length;let o=i.lut;const{offset:r}=i;o&&1===o[0].length&&(o=t.map(()=>o));const h=[],c=i.outputPixelType||"u8";for(let n=0;n<l;n++){const p=it(t[n],s,o[n],r||0,c);h.push(p)}const a=new X.Z({width:e.width,height:e.height,pixels:h,mask:s,pixelType:c});return a.updateStatistics(),a}function it(e,i,t,s,l){const o=e.length,r=X.Z.createEmptyBand(l,o);if(i)for(let h=0;h<o;h++)i[h]&&(r[h]=t[e[h]-s]);else for(let h=0;h<o;h++)r[h]=t[e[h]-s];return r}function mt(e,i){if(!Q(e))return null;const t=e.clone(),{pixels:s}=t,l=t.width*t.height,o=i.length,r=Math.floor(o/2),h=i[Math.floor(r)],c=s[0];let a,n,p,u,f,m,x=!1;const g=new Uint8Array(l),A=new Uint8Array(l),S=new Uint8Array(l);let P=t.mask;const T=4===i[0].mappedColor.length;for(P||(P=new Uint8Array(l),P.fill(T?255:1),t.mask=P),f=0;f<l;f++)if(P[f]){for(a=c[f],x=!1,m=r,n=h,p=0,u=o-1;u-p>1;){if(a===n.value){x=!0;break}a>n.value?p=m:u=m,m=Math.floor((p+u)/2),n=i[Math.floor(m)]}x||(a===i[p].value?(n=i[p],x=!0):a===i[u].value?(n=i[u],x=!0):a<i[p].value?(x=!1,n=null):a>i[p].value&&(a<i[u].value?(n=i[p],x=!0):u===o-1?(x=!1,n=null):(n=i[u],x=!0))),x?(g[f]=n.mappedColor[0],A[f]=n.mappedColor[1],S[f]=n.mappedColor[2],P[f]=n.mappedColor[3]):g[f]=A[f]=S[f]=P[f]=0}return t.pixels=[g,A,S],t.mask=P,t.pixelType="u8",t.maskIsAlpha=T,t}function Mt(e,i){if(!Q(e))return null;const{width:t,height:s}=e,{inputRanges:l,outputValues:o,outputPixelType:r,noDataRanges:h,allowUnmatched:c,isLastInputRangeInclusive:a}=i,n=e.pixels[0],p=X.Z.createEmptyBand(r,n.length),u=e.mask,f=new Uint8Array(t*s);u?f.set(u):f.fill(255);const m=e.pixelType.startsWith("f")?1e-6:0,x=l.map(T=>T-m);x[0]=l[0],x[x.length-1]=l[l.length-1]+(a?1e-6:0);const g=l.length/2,[A,S]=(0,gt.rL)(r);for(let T=0;T<s;T++)for(let D=0;D<t;D++){const L=T*t+D;if(f[L]){const W=n[L];let G=!1;for(let J=g-1;J>=0;J--)if(W===x[2*J]||W>x[2*J]&&W<x[2*J+1]){p[L]=o[J],G=!0;break}G||(c?p[L]=W>S?S:W<A?A:W:f[L]=0)}}const P=h?.length;if(P)for(let T=0;T<s;T++)for(let D=0;D<t;D++){const L=T*t+D;if(!u||u[L]){const W=n[L];for(let G=0;G<P;G+=2)if(W>=h[G]&&W<=h[G+1]){p[L]=0,f[L]=0;break}}}return new X.Z({width:t,height:s,pixelType:r,pixels:[p],mask:f})}function E(e,i,t,s){const l=null!=t&&t.length>=2?new Set(t):null,o=1===t?.length?t[0]:null,r=!!i?.length;for(let h=0;h<e.length;h++)if(s[h]){const c=e[h];if(r){let a=!1;for(let n=0;n<i.length;n+=2)if(c>=i[n]&&c<=i[n+1]){a=!0;break}a||(s[h]=0)}s[h]&&(c===o||l?.has(c))&&(s[h]=0)}}function B(e,i){const t=e[0].length;for(let s=0;s<t;s++)if(i[s]){let l=!1;for(let o=0;o<e.length;o++)if(e[o][s]){l=!0;break}l||(i[s]=0)}}function N(e,i){const t=e[0].length;for(let s=0;s<t;s++)if(i[s]){let l=!1;for(let o=0;o<e.length;o++)if(0===e[o][s]){l=!0;break}l&&(i[s]=0)}}function z(e,i){if(!Q(e))return null;const{width:t,height:s,pixels:l}=e,o=t*s,r=new Uint8Array(o);e.mask?r.set(e.mask):r.fill(255);const h=l.length,{includedRanges:c,noDataValues:a,outputPixelType:n,matchAll:p,lookups:u}=i;if(u){const f=[];for(let m=0;m<h;m++){const x=u[m],g=it(l[m],r,x.lut,x.offset||0,"u8");f.push(g)}1===f.length?r.set(f[0]):p?B(f,r):N(f,r)}else if(p){const f=[];for(let m=0;m<h;m++){const x=new Uint8Array(o);x.set(r),E(l[m],c?.slice(2*m,2*m+2),a?.[m],x),f.push(x)}1===f.length?r.set(f[0]):B(f,r)}else for(let f=0;f<h;f++)E(l[f],c?.slice(2*f,2*f+2),a?.[f],r);return new X.Z({width:t,height:s,pixelType:n,pixels:l,mask:r})}function Z(e){const{srcPixelType:i,inputRanges:t,outputValues:s,allowUnmatched:l,noDataRanges:o,isLastInputRangeInclusive:r,outputPixelType:h}=e;if("u8"!==i&&"s8"!==i&&"u16"!==i&&"s16"!==i)return null;const c=i.includes("16")?65536:256,a=i.includes("s")?-c/2:0,n=X.Z.createEmptyBand(h,c),p=new Uint8Array(c);l&&p.fill(255);const[u,f]=(0,gt.rL)(h);if(t?.length&&s?.length){const x=t.map(g=>g-1e-6);x[0]=t[0],r&&(x[x.length-1]=t[t.length-1]);for(let g=0;g<x.length;g++){const A=s[g]>f?f:s[g]<u?u:s[g],S=Math.ceil(x[2*g]-a),P=Math.floor(x[2*g+1]-a);for(let T=S;T<=P;T++)n[T]=A,p[T]=255}}if(o?.length)for(let m=0;m<o.length;m++){const x=Math.ceil(o[2*m]-a),g=Math.floor(o[2*m+1]-a);for(let A=x;A<=g;A++)p[A]=0}return{lut:n,offset:a,mask:p}}function j(e,i,t){if("u8"!==e&&"s8"!==e&&"u16"!==e&&"s16"!==e)return null;const s=e.includes("16")?65536:256,l=e.includes("s")?-s/2:0,o=new Uint8Array(s);if(i)for(let r=0;r<i.length;r++){const h=Math.ceil(i[2*r]-l),c=Math.floor(i[2*r+1]-l);for(let a=h;a<=c;a++)o[a]=255}else o.fill(255);if(t)for(let r=0;r<t.length;r++)o[t[r]-l]=0;return{lut:o,offset:l}}function tt(e,i){if(!e||0===e.length)return null;const t=e.find(m=>m.pixelBlock);if(null==t?.pixelBlock)return null;const s=(t.extent.xmax-t.extent.xmin)/t.pixelBlock.width,l=(t.extent.ymax-t.extent.ymin)/t.pixelBlock.height,o=.01*Math.min(s,l),r=e.sort((m,x)=>Math.abs(m.extent.ymax-x.extent.ymax)>o?x.extent.ymax-m.extent.ymax:Math.abs(m.extent.xmin-x.extent.xmin)>o?m.extent.xmin-x.extent.xmin:0),h=Math.min.apply(null,r.map(m=>m.extent.xmin)),c=Math.min.apply(null,r.map(m=>m.extent.ymin)),a=Math.max.apply(null,r.map(m=>m.extent.xmax)),n=Math.max.apply(null,r.map(m=>m.extent.ymax)),p={x:Math.round((i.xmin-h)/s),y:Math.round((n-i.ymax)/l)},u={width:Math.round((a-h)/s),height:Math.round((n-c)/l)},f={width:Math.round((i.xmax-i.xmin)/s),height:Math.round((i.ymax-i.ymin)/l)};return Math.round(u.width/t.pixelBlock.width)*Math.round(u.height/t.pixelBlock.height)!==r.length||p.x<0||p.y<0||u.width<f.width||u.height<f.height?null:{extent:i,pixelBlock:et(r.map(m=>m.pixelBlock),u,{clipOffset:p,clipSize:f})}}function R(e,i,t,s,l,o){const{width:r,height:h}=t.block,{x:c,y:a}=t.offset,{width:n,height:p}=t.mosaic,u=function O(e,i,t,s,l,o,r,h){return{xmin:l<=t*e?0:l<t*e+e?l-t*e:e,ymin:o<=s*i?0:o<s*i+i?o-s*i:i,xmax:l+r<=t*e?0:l+r<t*e+e?l+r-t*e:e,ymax:o+h<=s*i?0:o+h<s*i+i?o+h-s*i:i}}(r,h,s,l,c,a,n,p);let f=0,m=0;if(o){const x=o.hasGCSSShiftTransform?360:o.halfWorldWidth??0,g=r*o.resolutionX,A=o.startX+s*g;A<x&&A+g>x?m=o.rightPadding:A>=x&&(f=o.leftMargin-o.rightPadding,m=0)}if(u.xmax-=m,"number"!=typeof i)for(let x=u.ymin;x<u.ymax;x++){const g=(l*h+x-a)*n+(s*r-c)+f,A=x*r;for(let S=u.xmin;S<u.xmax;S++)e[g+S]=i[A+S]}else for(let x=u.ymin;x<u.ymax;x++){const g=(l*h+x-a)*n+(s*r-c)+f;for(let A=u.xmin;A<u.xmax;A++)e[g+A]=i}}function et(e,i,t={}){const{clipOffset:s,clipSize:l,alignmentInfo:o,blockWidths:r}=t;if(r)return function H(e,i,t){const s=e.find(g=>null!=g);if(null==s)return null;const l=e.some(g=>null==g||!!g.mask),{width:o,height:r}=i,h=l?new Uint8Array(o*r):null,{blockWidths:c}=t,a=[],n=s.getPlaneCount(),p=X.Z.getPixelArrayConstructor(s.pixelType);if(l)for(let g=0,A=0;g<e.length;A+=c[g],g++){const S=e[g];if(!Q(S))continue;const P=S.mask;for(let T=0;T<r;T++)for(let D=0;D<c[g];D++)h[T*o+D+A]=null==P?255:P[T*S.width+D]}const u=e.some(g=>g?.bandMasks&&g.bandMasks.length>1),f=u?[]:void 0,m=o*r;for(let g=0;g<n;g++){const A=new p(m),S=u?new Uint8Array(m):void 0;for(let P=0,T=0;P<e.length;T+=c[P],P++){const D=e[P];if(!Q(D))continue;const L=D.pixels[g];if(null!=L){for(let W=0;W<r;W++)for(let G=0;G<c[P];G++)A[W*o+G+T]=L[W*D.width+G];if(S){const W=D.bandMasks?.[g]??D.mask;for(let G=0;G<r;G++)for(let J=0;J<c[P];J++)S[G*o+J+T]=W?W[G*D.width+J]:255}}}a.push(A),f&&S&&f.push(S)}const x=new X.Z({width:o,height:r,mask:h,bandMasks:f,pixels:a,pixelType:s.pixelType});return x.updateStatistics(),x}(e,i,{blockWidths:r});const h=e.find(K=>Q(K));if(null==h)return null;const c=l?l.width:i.width,a=l?l.height:i.height,n=h.width,p=h.height,u=i.width/n,f=i.height/p,m={offset:s||{x:0,y:0},mosaic:l||i,block:{width:n,height:p}},x=h.pixelType,g=X.Z.getPixelArrayConstructor(x),A=h.pixels.length,S=[];let P,T;for(let K=0;K<A;K++){T=new g(c*a);for(let Y=0;Y<f;Y++)for(let F=0;F<u;F++){const nt=e[Y*u+F];Q(nt)&&(P=nt.pixels[K],R(T,P,m,F,Y,o))}S.push(T)}const D=e.some(K=>null==K||null!=K.mask&&K.mask.length>0),L=e.some(K=>K?.bandMasks&&K.bandMasks.length>1),W=D?new Uint8Array(c*a):void 0,G=L?[]:void 0;if(W){for(let K=0;K<f;K++)for(let Y=0;Y<u;Y++){const F=e[K*u+Y];R(W,(null!=F?F.mask:null)??(F?255:0),m,Y,K,o)}if(G)for(let K=0;K<A;K++){const Y=new Uint8Array(c*a);for(let F=0;F<f;F++)for(let nt=0;nt<u;nt++){const pt=e[F*u+nt];R(Y,pt?.bandMasks?.[K]??pt?.mask??(pt?255:0),m,nt,F,o)}G.push(Y)}}const J=new X.Z({width:c,height:a,pixels:S,pixelType:x,bandMasks:G,mask:W});return J.updateStatistics(),J}function U(e,i,t){if(!Q(e))return null;const{width:s,height:l}=e,o=i.x,r=i.y,h=t.width+o,c=t.height+r;if(o<0||r<0||h>s||c>l||0===o&&0===r&&h===s&&c===l)return e;e.mask||(e.mask=new Uint8Array(s*l));const a=e.mask;for(let n=0;n<l;n++){const p=n*s;for(let u=0;u<s;u++)a[p+u]=n<r||n>=c||u<o||u>=h?0:1}return e.updateStatistics(),e}function b(e){if(0===e.size)return 0;let i=0,t=-1,s=0;const l=e.keys();let o=l.next();for(;!o.done;)s=e.get(o.value),s>i&&(t=o.value,i=s),o=l.next();return t}function V(e,i,t){if(0===t)return;const s=e.get(i);1===s?e.delete(i):e.set(i,s-1)}function C(e,i,t){0!==t&&e.set(i,e.has(i)?e.get(i)+1:1)}function d(e,i,t){let{x:s,y:l}=i;const{width:o,height:r}=t;if(0===s&&0===l&&r===e.height&&o===e.width)return e;const{width:h,height:c}=e,a=Math.max(0,l),n=Math.max(0,s),p=Math.min(s+o,h),u=Math.min(l+r,c);if(p<0||u<0||!Q(e))return null;s=Math.max(0,-s),l=Math.max(0,-l);const{pixels:f}=e,m=o*r,x=f.length,g=[];for(let T=0;T<x;T++){const D=f[T],L=X.Z.createEmptyBand(e.pixelType,m);for(let W=a;W<u;W++){const G=W*h;let J=(W+l-a)*o+s;for(let K=n;K<p;K++)L[J++]=D[G+K]}g.push(L)}const A=new Uint8Array(m),S=e.mask;for(let T=a;T<u;T++){const D=T*h;let L=(T+l-a)*o+s;for(let W=n;W<p;W++)A[L++]=S?S[D+W]:1}const P=new X.Z({width:t.width,height:t.height,pixelType:e.pixelType,pixels:g,mask:A});return P.updateStatistics(),P}function M(e,i=!0){if(!Q(e))return null;const{pixels:t,width:s,height:l,mask:o,pixelType:r}=e,h=[],c=Math.round(s/2),a=Math.round(l/2),n=l-1,p=s-1;for(let f=0;f<t.length;f++){const m=t[f],x=X.Z.createEmptyBand(r,c*a);let g=0;for(let A=0;A<l;A+=2)for(let S=0;S<s;S+=2){const P=m[A*s+S];if(i){const T=S===p?P:m[A*s+S+1],D=A===n?P:m[A*s+S+s];x[g++]=(P+T+D+(S===p?D:A===n?T:m[A*s+S+s+1]))/4}else x[g++]=P}h.push(x)}let u=null;if(null!=o){u=new Uint8Array(c*a);let f=0;for(let m=0;m<l;m+=2)for(let x=0;x<s;x+=2){const g=o[m*s+x];if(i){const A=x===p?g:o[m*s+x+1],S=m===n?g:o[m*s+x+s];u[f++]=g*A*S*(x===p?S:m===n?A:o[m*s+x+s+1])?1:0}else u[f++]=g}}return new X.Z({width:c,height:a,pixelType:r,pixels:h,mask:u})}function w(e,i,t=0,s=!0){if(!Q(e))return null;const{width:l,height:o}=i;let{width:r,height:h}=e;const c=new Map,a={x:0,y:0},n=1+t;let p=e;for(let u=0;u<n;u++){const f=Math.ceil(r/l),m=Math.ceil(h/o);for(let x=0;x<m;x++){a.y=x*o;for(let g=0;g<f;g++){a.x=g*l;const A=d(p,a,i);c.set(`${u}/${x}/${g}`,A)}}u<n-1&&(p=M(p,s)),r=Math.round(r/2),h=Math.round(h/2)}return c}function k(e){const{pixelBlock:i,tileSize:t,level:s,row:l,col:o,useBilinear:r}=e;if(!Q(i))return null;const{width:h,height:c}=t,a=2**s,n=a*h,p=a*c;let u=d(i,{y:l*p,x:o*n},{width:n,height:p});if(!u)return null;for(let f=s;f>0;f--)u=M(u,r);return u}function y(e,i,t,s,l=0){const{width:o,height:r}=e,{width:h,height:c}=i,a=s.cols,n=s.rows,p=Math.ceil(h/a-.1/a),u=Math.ceil(c/n-.1/n);let f,m,x,g,A,S,P;const T=p*a,D=T*u*n,L=new Float32Array(D),W=new Float32Array(D),G=new Uint32Array(D),J=new Uint32Array(D);let K,Y,F=0;for(let nt=0;nt<u;nt++)for(let pt=0;pt<p;pt++){f=12*(nt*p+pt),m=t[f],x=t[f+1],g=t[f+2],A=t[f+3],S=t[f+4],P=t[f+5];for(let ct=0;ct<n;ct++){F=(nt*n+ct)*T+pt*a,Y=(ct+.5)/n;for(let st=0;st<ct;st++)K=(st+.5)/a,L[F+st]=(m*K+x*Y+g)*o+l,W[F+st]=(A*K+S*Y+P)*r+l,G[F+st]=Math.floor(L[F+st]),J[F+st]=Math.floor(W[F+st])}f+=6,m=t[f],x=t[f+1],g=t[f+2],A=t[f+3],S=t[f+4],P=t[f+5];for(let ct=0;ct<n;ct++){F=(nt*n+ct)*T+pt*a,Y=(ct+.5)/n;for(let st=ct;st<a;st++)K=(st+.5)/a,L[F+st]=(m*K+x*Y+g)*o+l,W[F+st]=(A*K+S*Y+P)*r+l,G[F+st]=Math.floor(L[F+st]),J[F+st]=Math.floor(W[F+st])}}return{offsets_x:L,offsets_y:W,offsets_xi:G,offsets_yi:J,gridWidth:T}}function _(e,i){const{coefficients:t,spacing:s}=i,{offsets_x:l,offsets_y:o,gridWidth:r}=y(e,e,t,{rows:s[0],cols:s[1]}),{width:h,height:c}=e,a=new Float32Array(h*c),n=180/Math.PI;for(let p=0;p<c;p++)for(let u=0;u<h;u++){const f=p*r+u,m=0===p?f:f-r,x=p===c-1?f:f+r,g=l[m]-l[x],A=o[x]-o[m];if(isNaN(g)||isNaN(A))a[p*h+u]=90;else{let S=Math.atan2(A,g)*n;S=(360+S)%360,a[p*h+u]=S}}return a}function I(e,i,t,s,l="nearest"){if(!Q(e))return null;"majority"===l&&(e=function v(e){if(!Q(e))return null;const i=e.clone(),{width:t,height:s,pixels:l}=e,o=l[0],r=i.pixels[0],h=e.mask;for(let c=2;c<s-1;c++){const a=new Map;for(let p=c-2;p<c+2;p++)for(let u=0;u<4;u++){const f=p*t+u;C(a,o[f],h?h[f]:1)}r[c*t]=b(a),r[c*t+1]=r[c*t+2]=r[c*t];let n=3;for(;n<t-1;n++){let p=(c-2)*t+n+1;C(a,o[p],h?h[p]:1),p=(c-1)*t+n+1,C(a,o[p],h?h[p]:1),p=c*t+n+1,C(a,o[p],h?h[p]:1),p=(c+1)*t+n+1,C(a,o[p],h?h[p]:1),p=(c-2)*t+n-3,V(a,o[p],h?h[p]:1),p=(c-1)*t+n-3,V(a,o[p],h?h[p]:1),p=c*t+n-3,V(a,o[p],h?h[p]:1),p=(c+1)*t+n-3,V(a,o[p],h?h[p]:1),r[c*t+n]=b(a)}r[c*t+n+1]=r[c*t+n]}for(let c=0;c<t;c++)r[c]=r[t+c]=r[2*t+c],r[(s-1)*t+c]=r[(s-2)*t+c];return i.updateStatistics(),i}(e));const{pixels:o,mask:r,bandMasks:h,pixelType:c}=e,a=e.width,n=e.height,p=X.Z.getPixelArrayConstructor(c),u=o.length,{width:f,height:m}=i;let x=!1;for(let F=0;F<t.length;F+=3)-1===t[F]&&-1===t[F+1]&&-1===t[F+2]&&(x=!0);const{offsets_x:g,offsets_y:A,offsets_xi:S,offsets_yi:P,gridWidth:T}=y({width:a,height:n},i,t,s,"majority"===l?.5:0);let D;const L=(F,nt,pt,ct)=>{const st=F instanceof Float32Array||F instanceof Float64Array?0:.5;for(let lt=0;lt<m;lt++){D=lt*T;for(let rt=0;rt<f;rt++){if(g[D]<0||A[D]<0)F[lt*f+rt]=0;else if(ct)F[lt*f+rt]=nt[S[D]+P[D]*a];else{const _t=Math.floor(g[D]),wt=Math.floor(A[D]),kt=Math.ceil(g[D]),At=Math.ceil(A[D]),bt=g[D]-_t,Pt=A[D]-wt;F[lt*f+rt]=!pt||pt[_t+wt*a]&&pt[kt+wt*a]&&pt[_t+At*a]&&pt[kt+At*a]?(1-Pt)*((1-bt)*nt[_t+wt*a]+bt*nt[kt+wt*a])+Pt*((1-bt)*nt[_t+At*a]+bt*nt[kt+At*a])+st:nt[S[D]+P[D]*a]}D++}}},W=[];let G;const J=h?.length===u,K=[];for(let F=0;F<u;F++){if(J){const nt=new Uint8Array(f*m);L(nt,h[F],h[F],!0),K.push(nt)}G=new p(f*m),L(G,o[F],J?h[F]:r,"nearest"===l||"majority"===l),W.push(G)}const Y=new X.Z({width:f,height:m,pixelType:c,pixels:W,bandMasks:J?K:void 0});if(null!=r)Y.mask=new Uint8Array(f*m),L(Y.mask,r,r,!0);else if(x){Y.mask=new Uint8Array(f*m);for(let F=0;F<f*m;F++)Y.mask[F]=g[F]<0||A[F]<0?0:1}return Y.updateStatistics(),Y}},89479:(vt,yt,$)=>{$.d(yt,{BH:()=>E,K:()=>b,KC:()=>mt,NL:()=>xt,QI:()=>Mt,Tg:()=>ot,Yx:()=>q,nb:()=>C,wF:()=>V,xQ:()=>it});var X=$(84303),gt=$(97493),at=$(98797);const ht=new Map;ht.set("meter-per-second",1),ht.set("kilometer-per-hour",.277778),ht.set("knots",.514444),ht.set("feet-per-second",.3048),ht.set("mile-per-hour",.44704);const dt=180/Math.PI,Q=5,xt=new X.X({esriMetersPerSecond:"meter-per-second",esriKilometersPerHour:"kilometer-per-hour",esriKnots:"knots",esriFeetPerSecond:"feet-per-second",esriMilesPerHour:"mile-per-hour"});function q(d,M){return ht.get(d)/ht.get(M)||1}function ut(d){return(450-d)%360}function ot(d,M="geographic"){const[w,k]=d,y=Math.sqrt(w*w+k*k);let _=Math.atan2(k,w)*dt;return _=(360+_)%360,"geographic"===M&&(_=ut(_)),[y,_]}function ft(d,M="geographic"){let w=d[1];"geographic"===M&&(w=ut(w)),w%=360;const k=d[0];return[k*Math.cos(w/dt),k*Math.sin(w/dt)]}function it(d,M,w,k="geographic"){if(!(0,at.nk)(d)||null==w)return d;const y="vector-magdir"===M?d.clone():mt(d,M),_=y.pixels[1];for(let I=0;I<_.length;I++)_[I]="geographic"===k?(_[I]+w[I]+270)%360:(_[I]+360-w[I])%360;return"vector-magdir"===M?y:mt(y,"vector-magdir")}function mt(d,M,w="geographic",k=1){if(!(0,at.nk)(d))return d;const{pixels:y,width:_,height:I}=d,e=_*I,i=y[0],t=y[1],s=d.pixelType.startsWith("f")?d.pixelType:"f32",l=gt.Z.createEmptyBand(s,e),o=gt.Z.createEmptyBand(s,e);let r=0;for(let c=0;c<I;c++)for(let a=0;a<_;a++)"vector-uv"===M?([l[r],o[r]]=ot([i[r],t[r]],w),l[r]*=k):([l[r],o[r]]=ft([i[r],t[r]],w),l[r]*=k,o[r]*=k),r++;const h=new gt.Z({pixelType:s,width:d.width,height:d.height,mask:d.mask,validPixelCount:d.validPixelCount,maskIsAlpha:d.maskIsAlpha,pixels:[l,o]});return h.updateStatistics(),h}function Mt(d,M,w=1){if(1===w||!(0,at.nk)(d))return d;const k=d.clone(),{pixels:y,width:_,height:I}=k,e=y[0],i=y[1];let t=0;for(let s=0;s<I;s++)for(let l=0;l<_;l++)"vector-uv"===M?(e[t]*=w,i[t]*=w):e[t]*=w,t++;return k.updateStatistics(),k}function E(d,M,w,k,y){if(null==y||!y.spatialReference.equals(d.spatialReference))return{extent:d,width:Math.round(M/k),height:Math.round(w/k),resolution:d.width/M};const _=y.xmin,I=y.ymax,e=(d.xmax-d.xmin)/M*k,i=(d.ymax-d.ymin)/w*k,t=(e+i)/2;return d.xmin=_+Math.floor((d.xmin-_)/e)*e,d.xmax=_+Math.ceil((d.xmax-_)/e)*e,d.ymin=I+Math.floor((d.ymin-I)/i)*i,d.ymax=I+Math.ceil((d.ymax-I)/i)*i,{extent:d,width:Math.round(d.width/e),height:Math.round(d.height/i),resolution:t}}const B=N(0,0,0);function N(d=0,M=0,w=Math.PI,k=!0){k&&(w=(2*Math.PI-w)%(2*Math.PI));const y=k?-1:1,_=13*y,I=-7*y,e=-2*y,i=-16*y,t=21.75,[s,l]=Z(0,M+_,w,t),[o,r]=Z(d-5.5,M+I,w,t),[h,c]=Z(d+5.5,M+I,w,t),[a,n]=Z(d-1.5,M+e,w,t),[p,u]=Z(d+1.5,M+e,w,t),[f,m]=Z(d-1.5,M+i,w,t),[x,g]=Z(d+1.5,M+i,w,t);return[s,l,o,r,a,n,p,u,h,c,f,m,x,g]}function z(d=0,M=Math.PI,w=!0){w&&(M=(2*Math.PI-M)%(2*Math.PI));const y=w?-1:1,_=5*y,I=20*y,e=25*y,i=45,r=2*y,h=w?1:-1,c=5*h;let[a,n]=[0+c,0-I],[p,u]=[a+2*h,n],[f,m]=[p-0*h,u+r],[x,g]=[0-c,0-e],[A,S]=[x+0*h,g-r],P=Math.ceil(d/Q),T=Math.floor(P/10);P-=8*T;const D=[],L=[];for(let st=0;st<P/2;st++,T--){T<=0&&P%2==1&&st===(P-1)/2&&(x=0,A=x+0*h,g=(g+n)/2,S=g-r);const[lt,rt]=Z(x,g,M,i);if(T>0){const[_t,wt]=Z(p,g,M,i),[kt,At]=Z(a,n,M,i);D.push(_t),D.push(wt),D.push(lt),D.push(rt),D.push(kt),D.push(At)}else{const[_t,wt]=Z(p,u,M,i),[kt,At]=Z(f,m,M,i),[bt,Pt]=Z(A,S,M,i);L.push(lt),L.push(rt),L.push(bt),L.push(Pt),L.push(kt),L.push(At),L.push(_t),L.push(wt)}g+=_,n+=_,u+=_,m+=_,S+=_}const[W,G]=Z(0+c,0+I,M,i),J=7*h,[K,Y]=Z(0+J,0+I,M,i),[F,nt]=Z(0+c,0-e,M,i),[pt,ct]=Z(0+J,0-e,M,i);return{pennants:D,barbs:L,shaft:[W,G,K,Y,F,nt,pt,ct]}}function Z(d,M,w,k=1){const y=Math.sqrt(d*d+M*M)/k,_=(2*Math.PI+Math.atan2(M,d))%(2*Math.PI);return[y,(2*Math.PI+_-w)%(2*Math.PI)]}const j=[0,1,3,6,10,16,21,27,33,40,47,55,63],O=[0,.5,1,1.5,2],tt=[0,.25,.5,1,1.5,2,2.5,3,3.5,4];function R(d,M,w,k){const y=q(k||"knots",w);let _;for(_=1;_<M.length;_++)if(_===M.length-1){if(d<M[_]*y)break}else if(d<=M[_]*y)break;return Math.min(_-1,M.length-2)}function et(d,M,w,k,y){let _=0;switch(M){case"beaufort_kn":_=R(d,j,"knots",w);break;case"beaufort_km":_=R(d,j,"kilometer-per-hour",w);break;case"beaufort_ft":_=R(d,j,"feet-per-second",w);break;case"beaufort_m":_=R(d,j,"meter-per-second",w);break;case"classified_arrow":_=R(d,y??[],k,w);break;case"ocean_current_m":_=R(d,O,"meter-per-second",w);break;case"ocean_current_kn":_=R(d,tt,"knots",w)}return _}const U=[];function b(d,M){let k=0,y=0;const{width:_,height:I,mask:e}=d,i=d.pixels[0],t=[],s=[],l=q(xt.fromJSON(M.inputUnit),"knots"),o="wind_speed"===M.style?Q:Number.MAX_VALUE;for(let r=0;r<I;r++)for(let h=0;h<_;h++){const c=i[r*_+h]*l;if((!e||e[r*_+h])&&c<o){for(let n=0;n<4;n++)t[k++]=(h+.5)/_,t[k++]=(r+.5)/I,t[k++]=n<2?-.5:.5,t[k++]=n%2==0?-.5:.5,t[k++]=0,t[k++]=c;const a=4*(k/24-1);s[y++]=a,s[y++]=a+1,s[y++]=a+2,s[y++]=a+1,s[y++]=a+2,s[y++]=a+3}}return{vertexData:new Float32Array(t),indexData:new Uint32Array(s)}}function V(d,M){return"simple_scalar"===M.style?b(d,M):"wind_speed"===M.style?function v(d,M){if(0===U.length)for(let r=0;r<30;r++)U.push(z(5*r,0,!M.invertDirection));const w=q(xt.fromJSON(M.inputUnit),"knots"),{width:k,height:y,mask:_}=d,I=d.pixels[0],e=d.pixels[1],t=[],s=[];let l=0,o=0;for(let r=0;r<y;r++)for(let h=0;h<k;h++){const c=r*k+h,a=I[c]*w;if((!_||_[r*k+h])&&a>=Q){const n=(e[c]+360)%360/180*Math.PI,{pennants:p,barbs:u,shaft:f}=U[Math.min(Math.floor(a/5),29)];if(p.length+u.length===0)continue;let m=t.length/6;const x=(h+.5)/k,g=(r+.5)/y;for(let A=0;A<p.length;A+=2)t[l++]=x,t[l++]=g,t[l++]=p[A],t[l++]=p[A+1]+n,t[l++]=0,t[l++]=a;for(let A=0;A<u.length;A+=2)t[l++]=x,t[l++]=g,t[l++]=u[A],t[l++]=u[A+1]+n,t[l++]=0,t[l++]=a;for(let A=0;A<f.length;A+=2)t[l++]=x,t[l++]=g,t[l++]=f[A],t[l++]=f[A+1]+n,t[l++]=0,t[l++]=a;for(let A=0;A<p.length/6;A++)s[o++]=m,s[o++]=m+1,s[o++]=m+2,m+=3;for(let A=0;A<u.length/8;A++)s[o++]=m,s[o++]=m+1,s[o++]=m+2,s[o++]=m+1,s[o++]=m+2,s[o++]=m+3,m+=4;s[o++]=m+0,s[o++]=m+1,s[o++]=m+2,s[o++]=m+1,s[o++]=m+3,s[o++]=m+2,m+=4}}return{vertexData:new Float32Array(t),indexData:new Uint32Array(s)}}(d,M):function H(d,M){const{style:w,inputUnit:k,outputUnit:y,breakValues:_}=M,I=xt.fromJSON(k),e=xt.fromJSON(y);let s=0,l=0;const{width:o,height:r,mask:h}=d,c=d.pixels[0],a=d.pixels[1],n=null!=h?h.filter(m=>m>0).length:o*r,p=new Float32Array(42*n),u=new Uint32Array(15*n),f=M.invertDirection?N(0,0,0,!1):B;for(let m=0;m<r;m++)for(let x=0;x<o;x++){const g=m*o+x;if(!h||h[m*o+x]){const A=(a[g]+360)%360/180*Math.PI,S=et(c[g],w,I,e,_);for(let T=0;T<f.length;T+=2)p[s++]=(x+.5)/o,p[s++]=(m+.5)/r,p[s++]=f[T],p[s++]=f[T+1]+A,p[s++]=S,p[s++]=c[g];const P=7*(s/42-1);u[l++]=P,u[l++]=P+1,u[l++]=P+2,u[l++]=P+0,u[l++]=P+4,u[l++]=P+3,u[l++]=P+0,u[l++]=P+2,u[l++]=P+3,u[l++]=P+2,u[l++]=P+5,u[l++]=P+3,u[l++]=P+5,u[l++]=P+6,u[l++]=P+3}}return{vertexData:p,indexData:u}}(d,M)}function C(d,M,w,k=[0,0],y=.5){const{width:_,height:I,mask:e}=d,[i,t]=d.pixels,[s,l]=k,o=Math.round((_-s)/w),r=Math.round((I-l)/w),h=o*r,c=new Float32Array(h),a=new Float32Array(h),n=new Uint8Array(h),p="vector-uv"===M;for(let f=0;f<r;f++)for(let m=0;m<o;m++){let x=0;const g=f*o+m,A=Math.max(0,f*w+l),S=Math.max(0,m*w+s),P=Math.min(I,A+w),T=Math.min(_,S+w);for(let D=A;D<P;D++)for(let L=S;L<T;L++){const W=D*_+L;if(!e||e[W]){x++;const G=p?[i[W],t[W]]:[i[W],(360+t[W])%360],[J,K]=p?G:ft(G);c[g]+=J,a[g]+=K}}if(x>=(P-A)*(T-S)*(1-y)){n[g]=1;const[D,L]=ot([c[g]/x,a[g]/x]);c[g]=D,a[g]=L}else n[g]=0,c[g]=0,a[g]=0}const u=new gt.Z({width:o,height:r,pixels:[c,a],mask:n});return u.updateStatistics(),u}},74155:(vt,yt,$)=>{$.d(yt,{GE:()=>it,KK:()=>tt});var X=$(15861),at=($(2189),$(14007)),ht=$(4703),dt=$(55117),Q=$(79412),xt=$(65311),q=$(33721),ut=$(26894);const ot=()=>ht.Z.getLogger("esri.views.2d.engine.flow.dataUtils"),ft=10;function it(U,v,b,V){return mt.apply(this,arguments)}function mt(){return(mt=(0,X.Z)(function*(U,v,b,V){const C=performance.now(),d=function Mt(U,v){const b=function N(U,v,b,V){if(0===V)return U;const C=Math.round(3*V),d=new Array(2*C+1);let M=0;for(let y=-C;y<=C;y++){const _=Math.exp(-y*y/(V*V));d[y+C]=_,M+=_}for(let y=-C;y<=C;y++)d[y+C]/=M;const w=new Float32Array(U.length);for(let y=0;y<b;y++)for(let _=0;_<v;_++){let I=0,e=0;for(let i=-C;i<=C;i++){if(_+i<0||_+i>=v)continue;const t=d[i+C];I+=t*U[2*(y*v+(_+i))],e+=t*U[2*(y*v+(_+i))+1]}w[2*(y*v+_)]=I,w[2*(y*v+_)+1]=e}const k=new Float32Array(U.length);for(let y=0;y<v;y++)for(let _=0;_<b;_++){let I=0,e=0;for(let i=-C;i<=C;i++){if(_+i<0||_+i>=b)continue;const t=d[i+C];I+=t*w[2*((_+i)*v+y)],e+=t*w[2*((_+i)*v+y)+1]}k[2*(_*v+y)]=I,k[2*(_*v+y)+1]=e}return k}(v.data,v.width,v.height,U.smoothing);return U.interpolate?(V,C)=>{const d=Math.floor(V),M=Math.floor(C);if(d<0||d>=v.width)return[0,0];if(M<0||M>=v.height)return[0,0];const w=V-d,k=C-M,I=d<v.width-1?d+1:d,e=M<v.height-1?M+1:M;return[(b[2*(M*v.width+d)]*(1-k)+b[2*(e*v.width+d)]*k)*(1-w)+(b[2*(M*v.width+I)]*(1-k)+b[2*(e*v.width+I)]*k)*w,(b[2*(M*v.width+d)+1]*(1-k)+b[2*(e*v.width+d)+1]*k)*(1-w)+(b[2*(M*v.width+I)+1]*(1-k)+b[2*(e*v.width+I)+1]*k)*w]}:(V,C)=>{const d=Math.round(V),M=Math.round(C);return d<0||d>=v.width||M<0||M>=v.height?[0,0]:[b[2*(M*v.width+d)],b[2*(M*v.width+d)+1]]}}(v,b),M=performance.now(),w=function B(U,v,b,V){const C=[],d=new xt.Z,M=1/Math.max(U.lineCollisionWidth,1),w=Math.round(b*M),k=Math.round(V*M),y=new Int32Array(w*k);for(let I=0;I<y.length;I++)y[I]=-1;const _=[];for(let I=0;I<V;I+=U.lineSpacing)for(let e=0;e<b;e+=U.lineSpacing)_.push({x:e,y:I,sort:d.getFloat()});_.sort((I,e)=>I.sort-e.sort);for(const{x:I,y:e}of _)if(d.getFloat()<U.density){const i=E(U,v,I,e,C.length,y,w,k,M);if(i.length<2)continue;C.push(i)}return C}(v,d,b.width,b.height),k=performance.now(),y=function z(U,v){const b=new xt.Z,V=U.reduce((k,y)=>k+y.length,0),C=new Float32Array(4*V),d=new Array(U.length);let M=0,w=0;for(const k of U){const y=M;for(const _ of k)C[4*M]=_.x,C[4*M+1]=_.y,C[4*M+2]=_.t,C[4*M+3]=_.speed,M++;d[w++]={startVertex:y,numberOfVertices:k.length,totalTime:k[k.length-1].t,timeSeed:v?b.getFloat():0}}return{lineVertices:C,lineDescriptors:d}}(w,!0),_=performance.now(),I="Streamlines"===U?function Z(U,v){const{lineVertices:V,lineDescriptors:C}=U;let d=0,M=0;for(const i of C)d+=2*i.numberOfVertices,M+=6*(i.numberOfVertices-1);const w=new Float32Array(9*d),k=new Uint32Array(M);let y=0,_=0;function e(i,t,s,l,o,r,h,c){const a=9*y;let n=0;w[a+n++]=i,w[a+n++]=t,w[a+n++]=1,w[a+n++]=s,w[a+n++]=r,w[a+n++]=h,w[a+n++]=l/2,w[a+n++]=o/2,w[a+n++]=c,y++,w[a+n++]=i,w[a+n++]=t,w[a+n++]=-1,w[a+n++]=s,w[a+n++]=r,w[a+n++]=h,w[a+n++]=-l/2,w[a+n++]=-o/2,w[a+n++]=c,y++}for(const i of C){const{totalTime:t,timeSeed:s}=i;let l=null,o=null,r=null,h=null,c=null,a=null;for(let n=0;n<i.numberOfVertices;n++){const p=V[4*(i.startVertex+n)],u=V[4*(i.startVertex+n)+1],f=V[4*(i.startVertex+n)+2],m=V[4*(i.startVertex+n)+3];let x=null,g=null,A=null,S=null;if(n>0){x=p-l,g=u-o;const P=Math.sqrt(x*x+g*g);if(x/=P,g/=P,n>1){let T=x+c,D=g+a;const L=Math.sqrt(T*T+D*D);T/=L,D/=L;const W=Math.min(1/(T*x+D*g),v);T*=W,D*=W,A=-D,S=T}else A=-g,S=x;null!==A&&null!==S&&(e(l,o,r,A,S,t,s,m),k[_++]=y-2,k[_++]=y,k[_++]=y-1,k[_++]=y,k[_++]=y+1,k[_++]=y-1)}l=p,o=u,r=f,c=x,a=g,h=m}e(l,o,r,-a,c,t,s,h)}return{vertexData:w,indexData:k}}(y,ft):function j(U){const{lineVertices:C,lineDescriptors:d}=U;let M=0,w=0;for(const P of d){const T=P.numberOfVertices-1;M+=4*T*2,w+=6*T*2}const k=new Float32Array(16*M),y=new Uint32Array(w);let _,I,e,i,t,s,l,o,r,h,c,a,n,p,u=0,f=0;function g(P,T){let D=r+c,L=h+a;const W=Math.sqrt(D*D+L*L);D/=W,L/=W;const G=r*D+h*L;D/=G,L/=G;let J=c+n,K=a+p;const Y=Math.sqrt(J*J+K*K);J/=Y,K/=Y;const F=c*J+a*K;J/=F,K/=F,function x(P,T,D,L,W,G,J,K,Y,F,nt,pt,ct,st){const lt=16*u;let rt=0;for(const _t of[1,2])for(const wt of[1,2,3,4])k[lt+rt++]=P,k[lt+rt++]=T,k[lt+rt++]=D,k[lt+rt++]=L,k[lt+rt++]=J,k[lt+rt++]=K,k[lt+rt++]=Y,k[lt+rt++]=F,k[lt+rt++]=_t,k[lt+rt++]=wt,k[lt+rt++]=ct,k[lt+rt++]=st,k[lt+rt++]=W/2,k[lt+rt++]=G/2,k[lt+rt++]=nt/2,k[lt+rt++]=pt/2,u++}(_,I,e,i,-L,D,t,s,l,o,-K,J,P,T),function m(){y[f++]=u-8,y[f++]=u-7,y[f++]=u-6,y[f++]=u-7,y[f++]=u-5,y[f++]=u-6,y[f++]=u-4,y[f++]=u-3,y[f++]=u-2,y[f++]=u-3,y[f++]=u-1,y[f++]=u-2}()}function A(P,T,D,L,W,G){if(r=c,h=a,c=n,a=p,null==r&&null==h&&(r=c,h=a),null!=t&&null!=s){n=P-t,p=T-s;const J=Math.sqrt(n*n+p*p);n/=J,p/=J}null!=r&&null!=h&&g(W,G),_=t,I=s,e=l,i=o,t=P,s=T,l=D,o=L}function S(P,T){r=c,h=a,c=n,a=p,null==r&&null==h&&(r=c,h=a),null!=r&&null!=h&&g(P,T)}for(const P of d){_=null,I=null,e=null,i=null,t=null,s=null,l=null,o=null,r=null,h=null,c=null,a=null,n=null,p=null;const{totalTime:T,timeSeed:D}=P;for(let L=0;L<P.numberOfVertices;L++)A(C[4*(P.startVertex+L)],C[4*(P.startVertex+L)+1],C[4*(P.startVertex+L)+2],C[4*(P.startVertex+L)+3],T,D);S(T,D)}return{vertexData:k,indexData:y}}(y),e=performance.now();return(0,at.Z)("esri-2d-profiler")&&(ot().info("I.1","_createFlowFieldFromData (ms)",Math.round(M-C)),ot().info("I.2","_getStreamlines (ms)",Math.round(k-M)),ot().info("I.3","createAnimatedLinesData (ms)",Math.round(_-k)),ot().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(e-_)),ot().info("I.5","createFlowMesh (ms)",Math.round(e-C)),ot().info("I.6","Mesh size (bytes)",I.vertexData.buffer.byteLength+I.indexData.buffer.byteLength)),yield Promise.resolve(),(0,Q.k_)(V),I})).apply(this,arguments)}function E(U,v,b,V,C,d,M,w,k){const y=[];let _=b,I=V,e=0,[i,t]=v(_,I);i*=U.velocityScale,t*=U.velocityScale;const s=Math.sqrt(i*i+t*t);let l,o;y.push({x:_,y:I,t:e,speed:s});for(let r=0;r<U.verticesPerLine;r++){let[h,c]=v(_,I);h*=U.velocityScale,c*=U.velocityScale;const a=Math.sqrt(h*h+c*c);if(a<U.minSpeedThreshold)return y;const n=h/a,p=c/a;if(_+=n*U.segmentLength,I+=p*U.segmentLength,e+=U.segmentLength/a,Math.acos(n*l+p*o)>U.maxTurnAngle)return y;if(U.collisions){const u=Math.round(_*k),f=Math.round(I*k);if(u<0||u>M-1||f<0||f>w-1)return y;const m=d[f*M+u];if(-1!==m&&m!==C)return y;d[f*M+u]=C}y.push({x:_,y:I,t:e,speed:a}),l=n,o=p}return y}function O(U,v){const b=v.pixels,{width:V,height:C}=v,d=new Float32Array(V*C*2),M=v.mask||new Uint8Array(V*C*2);if(v.mask||M.fill(255),"vector-uv"===U)for(let w=0;w<V*C;w++)d[2*w]=b[0][w],d[2*w+1]=-b[1][w];else if("vector-magdir"===U)for(let w=0;w<V*C;w++){const k=b[0][w],y=(0,dt.Vl)(b[1][w]),_=Math.cos(y-Math.PI/2),I=Math.sin(y-Math.PI/2);d[2*w]=_*k,d[2*w+1]=I*k}return{data:d,mask:M,width:V,height:C}}function tt(U,v,b,V,C,d){return R.apply(this,arguments)}function R(){return(R=(0,X.Z)(function*(U,v,b,V,C,d){const M=performance.now(),w=(0,q.C5)(v.spatialReference);if(!w){const c=yield et(U,v,b,V,C,d);return(0,at.Z)("esri-2d-profiler")&&ot().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-M)),(0,at.Z)("esri-2d-profiler")&&ot().info("I.9","Number of parts",1),c}const[k,y]=w.valid,I=Math.ceil(v.width/(y-k)),e=v.width/I,i=Math.round(b/I);let t=v.xmin;const s=[],l=performance.now();for(let c=0;c<I;c++){const a=new ut.Z({xmin:t,xmax:t+e,ymin:v.ymin,ymax:v.ymax,spatialReference:v.spatialReference});s.push(et(U,a,i,V,C,d)),t+=e}const o=yield Promise.all(s);(0,at.Z)("esri-2d-profiler")&&ot().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-l)),(0,at.Z)("esri-2d-profiler")&&ot().info("I.9","Number of parts",o.length);const r={data:new Float32Array(b*V*2),mask:new Uint8Array(b*V),width:b,height:V};let h=0;for(const c of o){for(let a=0;a<c.height;a++)for(let n=0;n<c.width;n++)h+n>=b||(r.data[2*(a*b+h+n)]=c.data[2*(a*c.width+n)],r.data[2*(a*b+h+n)+1]=c.data[2*(a*c.width+n)+1],r.mask[a*b+h+n]=c.mask[a*c.width+n]);h+=c.width}return(0,at.Z)("esri-2d-profiler")&&ot().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-M)),r})).apply(this,arguments)}function et(U,v,b,V,C,d){return H.apply(this,arguments)}function H(){return(H=(0,X.Z)(function*(U,v,b,V,C,d){const M={requestProjectedLocalDirections:!0,signal:d};if(null!=C&&(M.timeExtent=C),"imagery"===U.type){yield U.load({signal:d});const y=U.rasterInfo.dataType,_=yield U.fetchImage(v,b,V,M);return null==_?.pixelData?.pixelBlock?{data:new Float32Array(b*V*2),mask:new Uint8Array(b*V),width:b,height:V}:O(y,_.pixelData.pixelBlock)}yield U.load({signal:d});const w=U.serviceRasterInfo.dataType,k=yield U.fetchPixels(v,b,V,M);return null==k?.pixelBlock?{data:new Float32Array(b*V*2),mask:new Uint8Array(b*V),width:b,height:V}:O(w,k.pixelBlock)})).apply(this,arguments)}}}]);